# 操作系统实验报告（Lab 4）——进程管理机制

## 练习0：填写已有实验

本实验依赖于实验2和实验3的代码。已将lab3中相关代码填写labcode/lab4/kern/trap/trap.c
```c++
#include<sbi.h>

case IRQ_S_TIMER:
    clock_set_next_event();//发生这次时钟中断的时候，我们要设置下一次时钟中断
            if (++ticks % TICK_NUM == 0) {
                static int num = 0;
                print_ticks();
                num++;
                if (num == 10) {
                        sbi_shutdown();  // 调用关机函数
                }
             }   
```

---

## 练习1：分配并初始化一个进程控制块

### 实现过程

在 `alloc_proc` 函数中，首先通过 `kmalloc` 分配一段大小为 `sizeof(struct proc_struct)` 的内存空间用于存储新进程的管理信息。若分配成功，则对结构体中的各个字段进行初始化：

```c++
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        proc->state = PROC_UNINIT;      // 初始状态：未初始化
        proc->pid = -1;                 // pid 暂时设为 -1，等待 get_pid()
        proc->runs = 0;                 // 运行次数清零
        proc->kstack = 0;               // 内核栈指针尚未分配
        proc->need_resched = 0;         // 不需要立即调度
        proc->parent = NULL;            // 父进程为空
        proc->mm = NULL;                // 内核线程无用户内存管理结构
        memset(&(proc->context), 0, sizeof(struct context)); // 上下文清零
        proc->tf = NULL;                // trapframe 初始化为空，后续由 copy_thread 设置
        proc->pgdir = boot_pgdir_pa;    // 使用启动时的页表（内核线程共享）
        proc->flags = 0;                // 标志位清零
        memset(proc->name, 0, PROC_NAME_LEN + 1); // 名称清空
    }
    return proc;
}

```

#### 请说明 `proc_struct` 中 `struct context context` 和 `struct trapframe *tf` 成员变量含义和在本实验中的作用。

`struct context context` 是进程的执行上下文，主要保存在进程被调度切换时需要恢复的关键寄存器值，包括 `ra`（返回地址）和 `sp`（栈指针）。在本实验中，它用于 `switch_to` 函数实现两个进程之间的上下文切换，使得进程能够在中断执行后从上次停止的位置继续运行。

`struct trapframe *tf` 指向一个陷阱帧结构，记录了进程陷入内核前的完整 CPU 状态，包括通用寄存器、程序计数器 `epc`、状态寄存器 `status` 等。在本实验中，`tf` 被用于模拟新进程“刚刚从中断返回”的状态，在 `do_fork` 创建子进程时复制父进程的 `tf`，并通过 `forkrets` 函数加载该帧以恢复执行。

二者的关系在于：`context` 用于主动调度时的轻量级上下文切换，而 `tf` 用于从中断或系统调用返回时的现场恢复。两者共同构成了进程可暂停和恢复的基础机制。

---

## 练习2：为新创建的内核线程分配资源

### 实现过程

`do_fork` 函数负责完成内核线程的创建。其主要步骤如下：

1. 调用 `alloc_proc` 分配一个新的进程控制块；
2. 使用 `setup_kstack` 为其分配一页作为内核栈；
3. 调用 `copy_mm` 复制内存管理信息，但因当前为内核线程，此步不做实际处理；
4. 调用 `copy_thread` 设置新进程的 `trapframe` 和 `context`，并将入口设置为 `forkret`；
5. 调用 `get_pid` 获取唯一进程标识符，并赋给新进程；
6. 将新进程插入全局进程链表 `proc_list` 和哈希表 `hash_list`；
7. 调用 `wakeup_proc` 将其状态设为 `PROC_RUNNABLE`，使其可以被调度；
8. 增加进程总数 `nr_process`，返回新进程的 PID。

若中间任何一步失败，则跳转至错误清理标签释放已分配资源，确保无内存泄漏。
代码如下：
```c++
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 YOUR CODE
   // 1. 分配进程控制块
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }

    // 2. 分配内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 3. 复制内存管理信息
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    // 4. 设置 trapframe 和 context
    copy_thread(proc, stack, tf);

    // 5. 获取唯一 PID
    proc->pid = get_pid();

    // 6. 将进程加入哈希表和链表
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));

    // 7. 唤醒进程使其变为 RUNNABLE
    wakeup_proc(proc);

    // 8. 更新进程总数，返回子进程 PID
    nr_process++;
    ret = proc->pid;

    
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}

```



#### 请说明 ucore 是否做到给每个新 fork 的线程一个唯一的 id？请说明你的分析和理由。

是的，ucore 能够保证每个新创建的线程具有唯一的 PID。

`get_pid` 函数通过静态变量 `last_pid` 递增尝试分配 PID，并遍历当前所有进程检查是否存在冲突。若发现已被占用，则继续寻找下一个可用编号。同时维护 `next_safe` 变量以优化查找效率。由于最大 PID 数大于最大允许进程数，且每次分配都经过查重，因此能够确保生成的 PID 全局唯一。此外，在 `proc_init` 中对 `initproc` 的 PID 检查也为 1，验证了 PID 分配机制的正确性。

---

## 练习3：编写 `proc_run` 函数

### 实现过程

`proc_run` 函数用于将指定进程调度到 CPU 上运行。其实现步骤如下：

1. 判断目标进程是否与当前运行进程相同，若相同则无需切换；
2. 定义局部变量 `intr_flag`，调用 `local_intr_save(intr_flag)` 关闭中断，防止切换过程中发生中断干扰；
3. 更新全局 `current` 指针，指向即将运行的新进程；
4. 调用 `lsatp` 修改 SATP 寄存器，切换页表，使新进程的地址空间生效；
5. 调用汇编函数 `switch_to`，保存旧进程上下文并加载新进程的上下文；
6. 切换完成后，调用 `local_intr_restore(intr_flag)` 恢复中断状态。

该函数完成了从一个进程到另一个进程的完整切换流程
```c++
void proc_run(struct proc_struct *proc)
{
    if (proc != current)
    {
        // LAB4:EXERCISE3 YOUR CODE
        // 声明 intr_flag 变量用于保存中断状态
        bool intr_flag;

        local_intr_save(intr_flag); // 关闭中断，防止切换过程中被打断

        // 1. 记录旧进程，设置当前进程
        struct proc_struct *old = current;
        current = proc;

        // 2. 切换页表（SATP 寄存器）
        // 注意：proc->pgdir 是物理地址，需转换成 SATP 格式
        lsatp((proc->pgdir) >> RISCV_PGSHIFT);

        // 3. 执行上下文切换
        switch_to(&(old->context), &(proc->context));

        local_intr_restore(intr_flag); // 恢复中断

    }
}

```

#### 在本实验的执行过程中，创建且运行了几个内核线程？

在本实验的执行过程中，共创建并运行了两个内核线程：

1. **idleproc**：由 `proc_init` 直接调用 `alloc_proc` 创建，PID 为 0，名称为 "idle"，是系统第一个进程，负责初始化完成后进入主循环等待调度。
2. **initproc**：通过 `kernel_thread(init_main, ...)` 创建，PID 为 1，名称为 "init"，由 `do_fork` 机制派生，执行 `init_main` 函数并输出问候语。

这两个线程均成功运行，表明进程创建与调度机制工作正常。

---

## 扩展练习 Challenge

### 说明语句 `local_intr_save(intr_flag); ... local_intr_restore(intr_flag);` 是如何实现开关中断的？

`local_intr_save(intr_flag)` 和 `local_intr_restore(intr_flag)` 是基于 RISC-V 架构定义的宏。前者读取当前 `sstatus` 寄存器的值并保存到 `intr_flag`，然后清除其中的 `SIE` 位，从而关闭中断；后者将保存的原始值写回 `sstatus`，恢复中断使能状态。这种方式可以在临界区执行期间屏蔽中断，避免并发访问导致的数据不一致，同时在退出时准确恢复之前的中断状态，支持嵌套调用。

### get_pte() 函数中有两段形式类似的代码，结合 sv32，sv39，sv48 的异同，解释这两段代码为什么如此相像。

`get_pte` 函数中两段相似代码分别处理多级页表的不同层级。RISC-V 的 Sv32、Sv39、Sv48 分页模式均采用多级页表结构，每一级的操作逻辑一致：根据虚拟地址的若干位索引当前级页表项，判断其有效性，若无效且允许创建，则分配一页作为下一级页表并建立映射。尽管不同模式的级数和地址划分不同，但每层的处理模式相同，因此代码呈现高度相似性，体现了分页机制的层次化设计思想。

### 目前 get_pte() 函数将页表项的查找和分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

将查找和分配合并在一个函数中简化了接口，便于在需要确保页表存在的场合直接使用。但在某些场景下（例如仅需查询映射是否存在而不希望触发分配），自动分配会导致不必要的内存开销。因此，更好的做法是将其拆分为两个独立函数：`find_pte` 仅用于查找，`ensure_pte` 或类似接口用于查找并按需分配。这样职责更清晰，灵活性更高，也更利于调试和维护。

---

## 实验知识点总结

### 一、本实验中重要的知识点及对应的 OS 原理知识点

| 实验知识点 | 对应 OS 原理知识点 | 含义与理解 |
|-----------|--------------------|------------|
| `proc_struct` 的设计与初始化 | 进程控制块（PCB） | PCB 是操作系统对进程的抽象，包含进程状态、上下文、资源等信息，是进程管理的核心数据结构。 |
| `context` 与 `trapframe` 的使用 | 上下文切换与中断处理 | `context` 保存调度所需的最小上下文，`trapframe` 保存中断现场，二者分别服务于主动调度和被动陷入。 |
| `do_fork` 的实现 | 进程创建机制（fork） | 类 Unix 的 fork 机制通过复制父进程状态创建子进程，适用于内核线程和用户进程的派生。 |
| `get_pid` 的实现 | 进程标识符管理 | PID 是进程的唯一标识，必须全局唯一且高效分配，`get_pid` 通过查重机制保障唯一性。 |
| `proc_run` 与 `switch_to` | 进程调度与上下文切换 | 通过修改当前运行进程、切换页表和上下文，实现多任务并发执行。 |
| `local_intr_save/restore` | 中断屏蔽与原子操作 | 在关键路径上关闭中断，防止并发破坏数据结构，保证操作的原子性。 |
| `get_pte` 的实现 | 虚拟内存与页表管理 | 支持虚拟地址到物理地址的动态映射，是虚拟内存系统的基础组件。 |



## 总结

本次实验围绕进程管理机制展开，重点实现了进程控制块的初始化、内核线程的创建与资源分配、以及进程间的上下文切换。通过对 `alloc_proc`、`do_fork`、`proc_run` 等函数的编码与调试，掌握了操作系统中进程抽象的基本原理和实现方法。实验结果表明，系统能够成功创建并运行多个内核线程，各项机制工作正常。虽然目前仍局限于内核线程且部分功能尚未完善，但为后续实现用户进程和完整进程管理奠定了坚实基础。
