# 实验报告：连续物理内存分配算法的设计与实现

## 实验分工

组内成员均已独立完成各练习的实验。
---


## 实验一：理解 First-Fit 连续物理内存分配算法

### 1. 实验原理

**First-Fit（首次适配）算法**是一种最基本的物理内存分配方法。  
它的基本思想是：  
> 从空闲块链表的起始位置开始查找，找到第一个**大小足够**的空闲块后立即分配。

该算法在时间上效率较高，但随着分配与释放操作不断进行，内存空间会产生较多**外部碎片**。

### 2. 主要函数分析

#### （1）`default_init()`
用于初始化物理内存分配器，建立空闲页链表结构。
**执行流程：**  
1. 设置全局空闲链表 `free_list` 的初始状态；
2. 初始化空闲页计数变量 `nr_free`；
3. 调用 `list_init()` 函数建立双向循环链表；
4. 该函数通常在内存管理模块初始化时被调用一次。

#### （2）`default_init_memmap()`
扫描物理页，标记空闲页和已分配页，初始化空闲链表中的各节点信息。
**执行流程：**
1. 遍历从 `base` 到 `base + n - 1` 的页；
2. 设置每个页的状态字段：
   - `flags = 0`（清空标志位）；
   - `ref = 0`（引用计数清零）；
   - `property`：仅对块首页标记空闲块大小；
3. 调用 `list_add()` 将该块插入空闲链表；
4. 更新全局空闲页数量 `nr_free += n`。

#### （3）`default_alloc_pages()`
按照 First-Fit 策略，从空闲链表中查找第一个满足需求的空闲块，并进行分配。
**执行流程：**
1. **检查参数合法性**  
   确认请求页数 `n > 0`，否则直接触发断言错误。  

2. **遍历空闲链表（First Fit 策略）**  
   从 `free_list` 头节点开始，顺序查找第一个 `property >= n` 的空闲块。  

3. **判断空闲块大小**
   - 若空闲块 **刚好等于** 所需页数：直接取出该块，删除链表节点。  
   - 若空闲块 **大于** 所需页数：  
     将该空闲块从中间分割为两部分：
     - 前半部分分配出去；
     - 后半部分更新 `property` 并重新挂入空闲链表。

4. **更新全局变量**
   - 将 `nr_free` 减少 `n`；
   - 清除分配块的 `property` 值；
   - 设置引用计数 `ref = 1`，表示该页被占用。

5. **返回分配到的页块首地址**
   若找不到合适的空闲块，则返回 `NULL`，表示分配失败。

#### （4）`default_free_pages()`
释放页面，将其重新加入空闲链表，并尝试与相邻空闲块合并，减少碎片。
1. **参数检查与初始化**
   - 确保释放的页数 `n > 0`；
   - 将起始页 `base` 标记为空闲：`ClearPageReserved(base)`；
   - 设置 `property = n`，表示连续的空闲页数。

2. **插入空闲链表**
   - 按物理地址顺序在 `free_list` 中找到正确插入位置；
   - 避免打乱空闲块的地址顺序，便于后续合并。

3. **尝试合并相邻空闲块**
   - 检查前后两个块是否物理连续：
     - 若前块尾地址 == 当前块起始地址，则合并；
     - 若当前块尾地址 == 后块起始地址，也进行合并。
   - 合并后更新合并块的 `property` 值，删除多余节点。

4. **更新全局变量**
   - 将 `nr_free` 增加 `n`；
   - 若空闲链表合并成功，保证 `free_list` 始终为连续有序。

5. **结束**
   释放操作完成后，空闲页块重新可用于下一次分配。

### 3. 算法实现流程

1. 从空闲链表头部开始扫描；
2. 找到第一个 `p->property >= n` 的空闲块；
3. 若该空闲块大小大于需求，则将其分割；
4. 若刚好相等，则整块分配；
5. 更新空闲链表，返回分配的物理页指针。

### 4. 核心伪代码

```c
Page* default_alloc_pages(size_t n) {
    assert(n > 0);
    list_entry_t *le = &free_list;
    while ((le = list_next(le)) != &free_list) {
        Page *p = le2page(le, page_link);
        if (p->property >= n) {
            return alloc_from_block(p, n);
        }
    }
    return NULL; // 无可用空间
}
```

### 5. 优缺点分析

| 项目 | 内容 |
|------|------|
| 优点 | 实现简单、查找速度快 |
| 缺点 | 容易产生外部碎片、长时间运行后内存利用率下降 |

### 6. 改进空间

- **Next-Fit 改进**：记录上次分配结束的位置，下次从该处继续查找，减少重复遍历。  
- **Buddy System 改进**：采用一些算法管理空闲块来降低碎片率。  
- **动态合并机制**：在释放时合并相邻空闲块，减少空洞。

---

## 实验二：实现 Best-Fit 连续物理内存分配算法

### 1. 实验原理

**Best-Fit（最佳适配）算法**的基本思想是：
> 在所有空闲块中，选择**最小但足以满足需求**的块进行分配。

它能够有效减少外部碎片，但需要遍历所有空闲块，因此查找时间较长。

### 2. 实现思路

参考 `default_alloc_pages()` 函数，在分配过程中增加遍历逻辑，记录“当前最合适的块”，遍历结束后进行分配。

### 3. 核心代码示例

```c
Page* best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    list_entry_t *le = &free_list;
    Page *best = NULL;
    size_t best_size = ~0U;

    while ((le = list_next(le)) != &free_list) {
        Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < best_size) {
            best = p;
            best_size = p->property;
        }
    }

    if (best != NULL) {
        return alloc_from_block(best, n);
    }
    return NULL;
}
```

### 4. 实现流程

1. 遍历整个空闲链表；
2. 找出**最小且满足要求**的空闲块；
3. 对该块执行分配操作；
4. 若块未完全分配，则分割并更新链表；
5. 返回分配的页指针。

### 5. 优缺点分析

| 项目 | 内容 |
|------|------|
| 优点 | 能有效减少外部碎片，提高内存利用率 |
| 缺点 | 查找效率低，遍历所有空闲块导致时间复杂度较高 |

### 6. 改进空间

- **平衡树或红黑树优化**：用树结构管理空闲块，以 `O(log n)` 复杂度实现查找最小合适块。  
- **空闲块合并策略**：在释放时维护有序链表并自动合并相邻块。  
- **缓存最近分配结果**：在局部性强的情况下提升性能。

---

###扩展思考


