# Lab5 实验报告

## 练习0：填写已有实验

已成功将实验2、3、4的代码合并到本实验代码中，并确保能够正确执行Lab5的测试程序。

## 练习1：加载应用程序并执行（需要编码）

### 设计实现过程

在 `load_icode` 函数的第6步中，需要为用户进程设置用户态内存空间和 trapframe，具体实现如下：

1. **建立用户态内存空间**：
   - 调用 `mm_create` 创建进程内存管理结构。
   - 调用 `setup_pgdir` 建立页目录。
   - 调用 `mm_map` 分别映射代码段、数据段和堆栈段。
   - 设置用户态页表。

2. **设置 trapframe**：
   - 设置 trapframe 中的 `esp` 为用户栈顶。
   - 设置 `eip` 为程序入口地址（ELF头中指定）。
   - 设置 `cs`、`ds`、`es`、`ss` 为用户态段选择子。
   - 设置 `eflags` 允许中断。

### 执行过程描述

用户态进程从被调度为RUNNING态到执行第一条指令的过程：
1. 调度器选择该进程为当前运行进程。
2. `proc_run` 切换页表和内核栈。
3. 通过 `iret` 指令从 trapframe 恢复用户态上下文。
4. CPU 从 trapframe 中的 eip 开始执行，即应用程序的入口地址。

---

## 练习2：父进程复制自己的内存空间给子进程（需要编码）

### 设计实现过程

在 `copy_range` 函数中，实现父进程到子进程的内存复制：

1. 遍历父进程的每一页。
2. 对于存在的页面，申请新页并复制内容。
3. 建立子进程的页表映射。
4. 确保只复制用户空间（0~USERTOP）。

### Copy-on-Write 机制设计概要

**基本思路**：
- 父子进程初始共享所有只读页面。
- 页表项标记为只读。
- 当某一方尝试写时触发 page fault。
- 在 page fault 处理中复制页面并修改为可写。
- 更新页表，使写方拥有私有副本。

**实现细节**：
1. 在 `copy_range` 中不复制物理页，只共享页。
2. 页表项清除可写位。
3. 在 page fault 处理中判断是否为 COW 页面。
4. 如果是，则复制页面并设置可写。

---

## 练习3：fork/exec/wait/exit 函数分析

### 执行流程分析

#### fork
- **用户态**：调用 `sys_fork`。
- **内核态**：`do_fork` 创建新进程，复制内存和上下文。
- **返回**：父进程返回子进程PID，子进程返回0。

#### exec
- **用户态**：调用 `sys_exec`。
- **内核态**：`do_execve` 加载新程序，替换内存空间。
- **返回**：成功不返回，失败返回错误码。

#### wait
- **用户态**：调用 `sys_wait`。
- **内核态**：`do_wait` 等待子进程退出，回收资源。
- **返回**：子进程退出状态。

#### exit
- **用户态**：调用 `sys_exit`。
- **内核态**：`do_exit` 释放资源，通知父进程。
- **返回**：不返回。

### 内核态与用户态交错执行
- 系统调用通过 `int 0x80` 或 `syscall` 进入内核。
- 内核处理完毕后通过 `iret` 返回用户态。
- 结果通过寄存器（如eax）返回。

### 用户态进程执行状态生命周期图
PROC_UNINIT（创建）
|
| do_fork / init_main
|
PROC_RUNNABLE（就绪）
|
| schedule
|
PROC_RUNNING（运行）
|
| time interrupt / syscall
|
PROC_SLEEPING（等待） --- wakeup_proc --> PROC_RUNNABLE
|
| do_exit
|
PROC_ZOMBIE（僵尸）
|
| do_wait
|
PROC_UNINIT（回收）

---

## 重要知识点总结

### 实验中的知识点 vs. OS原理

| 实验知识点 | 对应原理知识点 | 理解与差异 |
|------------|----------------|------------|
| 进程创建（do_fork） | 进程创建（fork） | 实验实现中需复制内存、设置trapframe，原理中强调写时复制和资源复制 |
| 进程执行（load_icode） | 程序加载与执行 | 实验实现ELF解析和内存映射，原理中还包括动态链接和库加载 |
| 进程切换（proc_run） | 上下文切换 | 实验实现栈切换和寄存器保存，原理强调切换开销和调度策略 |
| 系统调用（syscall） | 用户态与内核态切换 | 实验使用中断门实现，原理包括调用门、sysenter等方式 |

### 实验中未涵盖的OS原理知识点

1. **进程调度算法**：实验中仅使用RR调度，未实现优先级、多级队列等。
2. **进程间通信（IPC）**：实验未实现管道、消息队列、共享内存等。
3. **线程机制**：实验中进程为唯一执行单位，未实现用户态或内核态线程。
4. **虚拟内存管理**：实验未实现请求分页、页面置换算法。
5. **文件系统与执行文件加载的完整流程**：实验仅实现ELF加载，未涉及动态链接和库依赖。

---

## 实验总结

通过本次实验，深入理解了用户进程的创建、加载、执行和退出的全过程，掌握了内存复制、ELF文件加载、系统调用处理等关键机制，并对进程状态切换和父子进程关系有了更直观的认识。
