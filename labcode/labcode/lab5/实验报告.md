# Lab5 用户进程管理 实验报告

## 实验结果

执行 `make grade` 后，所有测试用例均通过，总分为 130/130。

## 练习0：填写已有实验

本实验依赖实验2/3/4，需要在lab4的基础上进行更新，主要涉及进程控制块的初始化和进程创建时的关系设置。

### 1. alloc_proc 函数更新

在 `kern/process/proc.c` 的 `alloc_proc` 函数中，添加了lab5要求的字段初始化：

```c
// LAB5 YOUR CODE : (update LAB4 steps)
proc->wait_state = 0;              // 等待状态初始化为0
proc->cptr = NULL;                 // 子进程指针初始化为空
proc->yptr = NULL;                 // 兄弟进程指针初始化为空
proc->optr = NULL;                 // 兄弟进程指针初始化为空
```

这些字段用于管理进程间的父子兄弟关系，是 `do_wait` 函数查找子进程的基础。

### 2. do_fork 函数更新

在 `kern/process/proc.c` 的 `do_fork` 函数中，进行了两处更新：

**更新1：设置父子关系（步骤1后）**

```c
// LAB5: 设置子进程的父进程为当前进程，并确保当前进程的wait_state为0
proc->parent = current;
current->wait_state = 0;
```

**更新2：使用set_links设置进程关系（步骤5后）**

```c
// 6. 将进程加入哈希表和链表，并设置进程关系
hash_proc(proc);
// LAB5: 使用set_links设置进程关系（包括链表和父子兄弟关系）
// 注意：set_links已经包含了list_add和nr_process++，所以不需要重复
set_links(proc);
```

`set_links` 函数会统一处理进程链表的插入和父子兄弟关系的设置，避免了重复操作。

### 3. 时钟中断处理更新

在 `kern/trap/trap.c` 的 `interrupt_handler` 函数中，实现了时间片轮转调度：

```c
case IRQ_S_TIMER:
    // (1) 设置下一次时钟中断
    clock_set_next_event();
    // (2) ticks 计数器自增
    ticks++;
    // (3) 每 TICK_NUM 次中断，判断当前是否有进程正在运行，如果有则标记需要被重新调度
    if (ticks % TICK_NUM == 0)
    {
        // 如果当前有进程正在运行，标记需要重新调度
        if (current != NULL)
        {
            current->need_resched = 1;
        }
    }
    break;
```

这确保了即使进程在死循环中，也会被定期调度，从而能够检查 `PF_EXITING` 标志并正确退出。

## 练习1：加载应用程序并执行

### 设计实现过程

在 `load_icode` 函数的第6步中，需要设置 trapframe，使得进程能够从内核态返回到用户态并开始执行用户程序。

实现代码位于 `kern/process/proc.c` 的 `load_icode` 函数中：

```c
//(6) setup trapframe for user environment
struct trapframe *tf = current->tf;
// Keep sstatus
uintptr_t sstatus = tf->status;
memset(tf, 0, sizeof(struct trapframe));
// 设置用户栈指针为用户栈顶地址
tf->gpr.sp = USTACKTOP;
// 设置程序入口地址为ELF文件的入口点
tf->epc = elf->e_entry;
// 设置状态寄存器，配置为用户态模式：
// - 清除SPP位（0表示用户态，1表示内核态）
// - 设置SPIE位（允许在返回用户态时响应中断）
// - 保留原sstatus的其他位
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```

### 用户态进程从RUNNING态到执行第一条指令的经过

1. **进程被调度**：调度器选择该进程，调用 `proc_run(proc)`
2. **切换页表**：`lsatp(proc->pgdir)` 切换到进程的用户页表
3. **上下文切换**：`switch_to` 切换到进程的内核栈和上下文
4. **返回到用户态**：进程从 `forkret` 或 `kernel_execve_ret` 返回到 `__trapret`
5. **恢复trapframe**：`RESTORE_ALL` 宏恢复所有寄存器，包括 `sp`、`epc`、`status`
6. **执行sret**：硬件执行 `sret` 指令，从 `epc` 指定的地址开始执行，同时切换到用户态
7. **执行用户程序**：CPU从 `elf->e_entry` 地址开始执行用户程序的第一条指令

## 练习2：父进程复制自己的内存空间给子进程

### 设计实现过程

在 `copy_range` 函数中，需要将父进程的每个有效页复制到子进程，并在子进程的页表中建立映射。

实现代码位于 `kern/mm/pmm.c` 的 `copy_range` 函数中：

```c
// 从源页表项中提取权限位
uint32_t perm = (*ptep & PTE_USER);
// get page from ptep
struct Page *page = pte2page(*ptep);
// alloc a page for process B
struct Page *npage = alloc_page();
assert(page != NULL);
assert(npage != NULL);
int ret = 0;
// (1) 获取源页的内核虚拟地址
void *src_kvaddr = page2kva(page);
// (2) 获取目标页的内核虚拟地址
void *dst_kvaddr = page2kva(npage);
// (3) 从源页复制内容到目标页，大小为PGSIZE
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
// (4) 建立目标页的物理地址与线性地址start的映射关系
ret = page_insert(to, npage, start, perm);
```

**实现步骤：**

1. **提取权限位**：从源页表项中提取 `PTE_USER`，包含所有用户态权限位（`PTE_R | PTE_W | PTE_X | PTE_U | PTE_V`）
2. **获取源页和目标页**：通过 `pte2page` 获取源页，通过 `alloc_page` 分配新页
3. **获取内核虚拟地址**：使用 `page2kva` 将物理页转换为内核可访问的虚拟地址
4. **复制内存内容**：使用 `memcpy` 将源页内容复制到目标页
5. **建立页表映射**：使用 `page_insert` 在子进程页表中建立虚拟地址到物理页的映射

### Copy on Write (COW) 机制设计

**概要设计：**

1. **fork时的处理**：
   - 不立即复制物理页，而是让父子进程共享同一物理页
   - 将共享页的页表项设置为只读（清除 `PTE_W` 位）
   - 增加物理页的引用计数

2. **写操作时的处理**：
   - 当进程尝试写入共享页时，触发页错误异常（Page Fault）
   - 在页错误处理函数中检测到是COW页（通过页表项标志或页结构中的标志）
   - 分配新的物理页，复制原页内容
   - 更新页表项，指向新页，恢复写权限
   - 减少原页的引用计数

3. **数据结构扩展**：
   - 在 `Page` 结构中添加引用计数（已存在 `ref` 字段）
   - 可能需要添加COW标志位来标识COW页

**详细设计：**

```
fork流程：
1. do_fork调用copy_mm
2. copy_mm调用dup_mmap
3. dup_mmap调用copy_range，但设置share=true
4. copy_range中：
   - 不分配新页，直接让子进程页表项指向父进程的物理页
   - 清除页表项的PTE_W位（设为只读）
   - 增加物理页的引用计数：page_ref_inc(page)

页错误处理：
1. 发生Store Page Fault异常
2. trap函数调用page_fault_handler
3. 检查页表项：
   - 如果页表项有效但无写权限，且是COW页
   - 分配新页：npage = alloc_page()
   - 复制内容：memcpy(page2kva(npage), page2kva(page), PGSIZE)
   - 更新页表项：page_insert(pgdir, npage, addr, perm | PTE_W)
   - 减少原页引用：page_ref_dec(page)
   - 如果引用计数为0，释放原页
```

**关键点：**
- 需要在页错误处理中区分COW页和真正的只读页
- 可以通过检查页的引用计数 > 1 来判断是否为COW页
- 需要处理多进程共享同一COW页的情况

---

## 练习3：fork/exec/wait/exit 函数分析

### 执行流程分析

#### fork
- **用户态**：调用 `sys_fork`。
- **内核态**：`do_fork` 创建新进程，复制内存和上下文。
- **返回**：父进程返回子进程PID，子进程返回0。

#### exec
- **用户态**：调用 `sys_exec`。
- **内核态**：`do_execve` 加载新程序，替换内存空间。
- **返回**：成功不返回，失败返回错误码。

#### wait
- **用户态**：调用 `sys_wait`。
- **内核态**：`do_wait` 等待子进程退出，回收资源。
- **返回**：子进程退出状态。

#### exit
- **用户态**：调用 `sys_exit`。
- **内核态**：`do_exit` 释放资源，通知父进程。
- **返回**：不返回。

### 内核态与用户态交错执行
- 系统调用通过 `int 0x80` 或 `syscall` 进入内核。
- 内核处理完毕后通过 `iret` 返回用户态。
- 结果通过寄存器（如eax）返回。

### 用户态进程执行状态生命周期图
PROC_UNINIT（创建）
|
| do_fork / init_main
|
PROC_RUNNABLE（就绪）
|
| schedule
|
PROC_RUNNING（运行）
|
| time interrupt / syscall
|
PROC_SLEEPING（等待） --- wakeup_proc --> PROC_RUNNABLE
|
| do_exit
|
PROC_ZOMBIE（僵尸）
|
| do_wait
|
PROC_UNINIT（回收）

---

## 重要知识点总结

### 实验中的知识点 vs. OS原理

| 实验知识点 | 对应原理知识点 | 理解与差异 |
|------------|----------------|------------|
| 进程创建（do_fork） | 进程创建（fork） | 实验实现中需复制内存、设置trapframe，原理中强调写时复制和资源复制 |
| 进程执行（load_icode） | 程序加载与执行 | 实验实现ELF解析和内存映射，原理中还包括动态链接和库加载 |
| 进程切换（proc_run） | 上下文切换 | 实验实现栈切换和寄存器保存，原理强调切换开销和调度策略 |
| 系统调用（syscall） | 用户态与内核态切换 | 实验使用中断门实现，原理包括调用门、sysenter等方式 |

### 实验中未涵盖的OS原理知识点

1. **进程调度算法**：实验中仅使用RR调度，未实现优先级、多级队列等。
2. **进程间通信（IPC）**：实验未实现管道、消息队列、共享内存等。
3. **线程机制**：实验中进程为唯一执行单位，未实现用户态或内核态线程。
4. **虚拟内存管理**：实验未实现请求分页、页面置换算法。
5. **文件系统与执行文件加载的完整流程**：实验仅实现ELF加载，未涉及动态链接和库依赖。

---

## 实验总结

通过本次实验，深入理解了用户进程的创建、加载、执行和退出的全过程，掌握了内存复制、ELF文件加载、系统调用处理等关键机制，并对进程状态切换和父子进程关系有了更直观的认识。


