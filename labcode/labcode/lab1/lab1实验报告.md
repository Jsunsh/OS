
# 实验报告：RISC-V 系统启动流程分析

**姓名**：贾双双、王玥、杨泽宇 
**学号**：2313936
**日期**：2025年10月7日  
**课程**：操作系统

---

## 一、实验目的

1. 掌握使用 QEMU 和 GDB 调试 RISC-V 系统的方法
2. 理解操作系统从加电到内核初始化的完整启动流程
3. 分析 RISC-V 架构的启动特性和内存布局
4. 理解内核入口代码的功能和设计原理

---

## 二、实验环境

| 项目 | 配置 |
|------|------|
| 模拟器 | QEMU 4.1.1 |
| 调试器 | riscv64-unknown-elf-gdb 10.1.0 |
| 目标架构 | RISC-V 64位 |
| 开发平台 | WSL2 + Ubuntu 24.04 |
| 工具链 | SiFive RISC-V GCC 10.2.0 |

---

## 三、基本原理分析

### 3.1 操作系统启动流程概述

操作系统启动是一个分层递进的过程：

```
加电 → BIOS/UEFI → Bootloader → Kernel → Init Process
```

在 RISC-V 架构中，这个过程具体化为：

加电 → OpenSBI(firmware) → 内核入口(entry.S) → kern_init() → 系统运行


### 3.2 RISC-V 特权架构与启动机制

#### 特权级别 (Privilege Levels)
- **M-mode (Machine Mode)**：最高权限，OpenSBI 运行在此模式
- **S-mode (Supervisor Mode)**：操作系统内核运行模式  
- **U-mode (User Mode)**：应用程序运行模式

启动过程是权限逐级下降的过程：`M-mode → S-mode → U-mode`

#### 内存映射布局
```
0x0000_1000 - 0x0000_8000: 复位向量和初始代码
0x8000_0000 - 0x8000_FFFF: OpenSBI 固件区域
0x8020_0000 - 0x8XXX_XXXX: 操作系统内核区域
```

### 3.3 内核入口关键操作原理

#### 栈初始化的重要性
- **栈的作用**：为函数调用提供局部变量存储、返回地址保存、参数传递的空间
- **内核栈**：操作系统内核执行时需要独立的栈空间，与用户程序隔离
- **初始化时机**：必须在执行任何 C 代码之前完成栈设置

#### 控制流转移机制
- **尾调用优化**：`tail` 指令确保跳转到 `kern_init` 时优化栈帧使用
- **权限切换**：从汇编环境切换到 C 语言运行环境

---

## 四、实验内容与步骤

### 练习1：理解内核启动中的程序入口操作

#### 4.1.1 分析 entry.S 代码

```
#include <mmu.h>
#include <memlayout.h>

    .section .text,"ax",%progbits
    .globl kern_entry
kern_entry:
    la sp, bootstacktop

    tail kern_init

.section .data
    # .align 2^12
    .align PGSHIFT
    .global bootstack
bootstack:
    .space KSTACKSIZE
    .global bootstacktop
bootstacktop:
```

#### 4.1.2 关键指令分析

**指令1：`la sp, bootstacktop`**

- **操作功能**：
  - `la` (Load Address) 是伪指令，将 `bootstacktop` 的地址加载到 `sp` (Stack Pointer) 寄存器
  - 设置内核栈的栈顶指针

- **设计目的**：
  - 为内核代码的执行准备运行环境
  - 确保后续的函数调用有可用的栈空间
  - 建立内核的内存管理基础

**指令2：`tail kern_init`**

- **操作功能**：
  - `tail` 是尾调用指令，跳转到 `kern_init` 函数
  - 与直接 `call` 的区别：不保存返回地址，优化栈使用

- **设计目的**：
  - 从汇编启动代码转移到 C 语言主初始化函数
  - 开始执行操作系统的核心逻辑
  - 完成启动阶段的控制权转移

#### 4.1.3 原理与实现关系

| OS 原理概念 | 实验中的实现 | 关系说明 |
|------------|-------------|----------|
| 进程上下文 | 栈指针设置 | 内核需要独立的执行环境 |
| 函数调用机制 | 尾调用优化 | 提高启动效率，减少栈消耗 |
| 系统初始化 | 控制流转移 | 从底层初始化到高级逻辑 |

### 练习2：使用 GDB 验证启动流程

#### 4.2.1 实验步骤记录

**步骤1：启动调试环境**

终端1 - 启动 QEMU：
```bash
cd ~/lab/labcode/lab1
qemu-system-riscv64 -machine virt -nographic -bios default -kernel bin/kernel -s -S
```

终端2 - 启动 GDB 调试：
```bash
cd ~/lab/labcode/lab1
riscv64-unknown-elf-gdb bin/kernel
(gdb) target remote :1234
```

**步骤2：在复位地址设置断点**

```bash
(gdb) b *0x1000
(gdb) c
```

**得到以下输出信息：**

```
Breakpoint 2 at 0x1000
Continuing.

Breakpoint 1, 0x0000000000001000 in ?? ()
```

**步骤3：分析复位代码**

```bash
(gdb) x/10i $pc
```

**得到以下 0x1000 处的前10条指令：**

```
=> 0x1000:      auipc   t0,0x0
   0x1004:      addi    a1,t0,32
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      t0,24(t0)
   0x1010:      jr      t0
   0x1014:      unimp
   0x1016:      unimp
   0x1018:      unimp
   0x101a:      0x8000
   0x101c:      unimp
```

**步骤4：观察寄存器状态**

```bash
(gdb) info registers
```

**得到关键寄存器的初始值：**

```
t0             0x80000000       2147483648
a1             0x1020   4128
```

**步骤5：设置内核入口监视**

```bash
(gdb) watch *0x80200000
(gdb) b *0x80200000
(gdb) c
```

**步骤6：分析内核入口代码**

当停在 0x80200000 时：
```bash
(gdb) x/5i $pc
(gdb) info registers sp
```

**得到内核入口处的z指令和栈指针值：**

```
(gdb) x/5i $pc
=> 0x80200000 <kern_entry>:     auipc   sp,0x3
   0x80200004 <kern_entry+4>:   mv      sp,sp
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>
   0x8020000a <kern_init>:      auipc   a0,0x3
   0x8020000e <kern_init+4>:    addi    a0,a0,-2

sp             0x8001bd80       0x8001bd80
```

#### 4.2.2 调试结果分析

**问题1：RISC-V 硬件加电后最初执行的几条指令位于什么地址？**


RISC-V 硬件加电后最初执行的指令位于地址 0x1000，这是 RISC-V 架构规定的复位向量地址。从调试结果可以看到，程序确实从 0x1000 开始执行复位代码。


**问题2：这些指令主要完成了哪些功能？**
基于调试观察到的指令，这些复位指令主要完成以下功能：
1. **地址计算**：`auipc t0,0x0` 计算当前PC相对地址，为后续跳转做准备
2. **参数设置**：`addi a1,t0,32` 设置参数地址到 a1 寄存器（0x1000 + 32 = 0x1020）
3. **硬件识别**：`csrr a0,mhartid` 读取当前硬件线程ID到 a0 寄存器
4. **固件加载**：`ld t0,24(t0)` 从地址 0x1018 加载 OpenSBI 固件的入口地址到 t0
5. **控制转移**：`jr t0` 跳转到 OpenSBI 固件执行，完成从硬件复位到固件执行的过渡





---

## 五、知识点分析

### 5.1 实验中的重要知识点

| 实验知识点 | 对应的OS原理知识点 | 理解与关系 |
|-----------|-------------------|------------|
| 复位向量(0x1000) | 计算机体系结构启动机制 | RISC-V 特定的启动地址约定，体现了硬件与软件的接口规范 |
| OpenSBI 固件 | BIOS/UEFI 系统 | 开源版本的底层系统固件，完成硬件初始化和内核加载 |
| 内核加载地址(0x80200000) | 内存布局设计 | 避开固件区域，为内核提供连续地址空间 |
| 栈指针初始化 | 进程执行环境 | 内核作为"特殊进程"需要独立的运行栈 |
| 控制流转移 | 系统启动流程 | 从底层固件到高级操作系统的权限和责任传递 |

### 5.2 实验中未覆盖的OS重要原理

 **进程调度**：启动阶段只有单一线程，未体现多进程调度
 **系统调用接口**：内核初始化阶段尚未建立完整的系统调用机制
 **文件系统**：实验聚焦启动过程，未涉及存储设备访问
 **中断处理**：简单的初始化环境，完整的中断体系尚未建立


